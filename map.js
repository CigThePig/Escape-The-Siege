import { GRID_W, GRID_H, CHESTS_PER_RUN, SPAWN_MIN_RADIUS } from './constants.js';

function generateMaze(width,height){const w=(width%2===0)?width-1:width,h=(height%2===0)?height-1:height;const grid=Array.from({length:height},()=>Array(width).fill(1));function inBoundsCarve(x,y){return x>0&&x<w-1&&y>0&&y<h-1}const stack=[];let cx=1,cy=1;grid[cy][cx]=0;stack.push([cx,cy]);function neighbors(x,y){return[[x+2,y],[x-2,y],[x,y+2],[x,y-2]].filter(([nx,ny])=>inBoundsCarve(nx,ny)&&grid[ny][nx]===1)}while(stack.length){const [x,y]=stack[stack.length-1];const nbs=neighbors(x,y);if(!nbs.length){stack.pop();continue}const [nx,ny]=nbs[(Math.random()*nbs.length)|0];grid[ny][nx]=0;grid[y+(ny-y)/2][x+(nx-x)/2]=0;stack.push([nx,ny])}for(let y=1;y<height-1;y++){for(let x=1;x<width-1;x++){if(grid[y][x]===0&&Math.random()<.22){if(grid[y][x+1]===1)grid[y][x+1]=0;if(grid[y+1][x]===1)grid[y+1][x]=0}}}return grid}
function carveRect(grid,x,y,w,h){for(let j=0;j<h;j++)for(let i=0;i<w;i++){const gx=x+i,gy=y+j;if(gx>0&&gy>0&&gx<GRID_W-1&&gy<GRID_H-1)grid[gy][gx]=0}}
function carveGuidedPath(grid,start,exit){let x=start.x,y=start.y;grid[y][x]=0;if(y+1<GRID_H)grid[y+1][x]=0;const steps=GRID_W*2;let dirY=0;for(let s=0;s<steps&&x<exit.x-1;s++){const r=Math.random();if(r<.70){x=Math.min(GRID_W-2,x+1)}else{if(dirY===0)dirY=Math.random()<.5?-1:1;else if(Math.random()<.4)dirY=0;y=Math.max(1,Math.min(GRID_H-3,y+dirY))}grid[y][x]=0;grid[y+1][x]=0;if(Math.random()<.30&&x<exit.x-2){grid[y][x+1]=1;grid[y+1][x+1]=1;const off=(Math.random()<.5?-1:1);const yy=Math.max(1,Math.min(GRID_H-3,y+off));grid[yy][x]=0;grid[yy+1][x]=0;grid[yy][x+2]=0;grid[yy+1][x+2]=0;x=x+2;y=yy}}grid[exit.y][exit.x]=0;if(exit.x-1>=0)grid[exit.y][exit.x-1]=0}
function addRoomsAndConnectors(grid){const roomCount=3+((Math.random()*2)|0);for(let r=0;r<roomCount;r++){const rw=3+((Math.random()*3)|0),rh=3+((Math.random()*2)|0),rx=2+((Math.random()*(GRID_W-rw-4))|0),ry=2+((Math.random()*(GRID_H-rh-4))|0);carveRect(grid,rx,ry,rw,rh)}for(let y=2;y<GRID_H-2;y++){for(let x=2;x<GRID_W-2;x++){if(grid[y][x]!==1)continue;const horiz=(grid[y][x-1]===0&&grid[y][x+1]===0&&grid[y-1][x]===1&&grid[y+1][x]===1);const vert=(grid[y-1][x]===0&&grid[y+1][x]===0&&grid[y][x-1]===1&&grid[y][x+1]===1);if((horiz||vert)&&Math.random()<.08)grid[y][x]=0}}}
function randomFloor(grid){for(let tries=0;tries<6000;tries++){const x=(Math.random()*GRID_W)|0,y=(Math.random()*GRID_H)|0;if(grid[y][x]===0)return{x,y}}return{x:1,y:1}}
function dist1(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)}
export function pathExists(grid,start,goal){const q=[start];const seen=new Set([start.x+','+start.y]);const dirs=[[1,0],[-1,0],[0,1],[0,-1]];while(q.length){const cur=q.shift();if(cur.x===goal.x&&cur.y===goal.y)return true;for(let i=0;i<4;i++){const nx=cur.x+dirs[i][0],ny=cur.y+dirs[i][1];if(nx<0||ny<0||nx>=GRID_W||ny>=GRID_H)continue;if(grid[ny][nx]===1)continue;const key=nx+','+ny;if(!seen.has(key)){seen.add(key);q.push({x:nx,y:ny})}}}return false}
export function buildMap(){let grid,start,exit,attempts=0;do{grid=generateMaze(GRID_W,GRID_H);start={x:0,y:(GRID_H/2)|0};exit={x:GRID_W-1,y:(GRID_H/2)|0};grid[start.y][start.x]=0;if(start.x+1<GRID_W)grid[start.y][start.x+1]=0;carveGuidedPath(grid,start,exit);addRoomsAndConnectors(grid);attempts++;if(attempts>50)break}while(!pathExists(grid,start,exit));const spawners=[];const edgeOptions=[];for(let y=0;y<GRID_H;y++){if(grid[y][0]===0)edgeOptions.push({x:0,y});if(grid[y][GRID_W-1]===0)edgeOptions.push({x:GRID_W-1,y})}for(let x=0;x<GRID_W;x++){if(grid[0][x]===0)edgeOptions.push({x,y:0});if(grid[GRID_H-1][x]===0)edgeOptions.push({x,y:GRID_H-1})}edgeOptions.sort(()=>Math.random()-.5);for(const p of edgeOptions){if(dist1(p,start)<SPAWN_MIN_RADIUS)continue;if(!((p.x===start.x&&p.y===start.y)||(p.x===exit.x&&p.y===exit.y)))spawners.push(p);if(spawners.length>=3)break}while(spawners.length<3){const p=randomFloor(grid);if(dist1(p,start)<SPAWN_MIN_RADIUS)continue;if((p.x===start.x&&p.y===start.y)||(p.x===exit.x&&p.y===exit.y))continue;spawners.push(p)}if(!spawners.some(s=>s.x>=Math.floor(GRID_W*.6))){for(let tries=0;tries<200;tries++){const x=Math.floor(GRID_W*.7)+((Math.random()*Math.floor(GRID_W*.3))|0);const y=(Math.random()*GRID_H)|0;const p={x,y};if(x>=0&&x<GRID_W&&y>=0&&y<GRID_H&&grid[y][x]===0&&dist1(p,start)>=SPAWN_MIN_RADIUS){spawners[0]=p;break}}}const chests=[];for(let i=0;i<CHESTS_PER_RUN;i++){const p=randomFloor(grid);if((p.x===start.x&&p.y===start.y)||(p.x===exit.x&&p.y===exit.y)){i--;continue}if(spawners.some(s=>s.x===p.x&&s.y===p.y)){i--;continue}chests.push({x:p.x,y:p.y,opened:false})}return{grid,start,exit,spawners,chests}}
