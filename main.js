(() => {

const GRID_W=30,GRID_H=30;const PASSIVE_MANA=1,START_MANA=10,START_HP=10;
const CHEST_MANA=8;const COSTS={arrow:9,rune:10,fire:16,spike:6};
const TRAP_RANGE=4,TRAP_DMG=2;const RUNE_RADIUS=1,FIRE_DMG=3,FIRE_RADIUS=1,SPIKE_DMG=8;const PLACE_RADIUS=4;
const ARROW_AMMO=5;const BURN_TURNS=2,BURN_DMG=1;const RUNE_SLOW_TURNS=2;
const DASH_CD=8,DASH_COST=3;
const DENSITY_TILE_WEIGHT=.5,DENSITY_NEIGHBOR_WEIGHT=.25,PATIENCE_PROB=.2,PATROL_RADIUS=12;
const ENEMY={goblin:{hp:3,touch:2,reward:1,speed:1},archer:{hp:4,touch:1,reward:2,speed:1,range:4,cd:3,dmg:2},wraith:{hp:6,touch:3,reward:4,speed:1,phaser:true}};
function baseSpawnCooldown(t){return Math.max(2,4-Math.floor(t/20))}function baseSpawnCount(t){return 1+Math.floor(t/15)}
const ENEMY_CAP=18,CHESTS_PER_RUN=5,SPAWN_MIN_RADIUS=6;
const COLORS={wall:'#0a0e1a',wallEdge:'#3b486b',floor:'#263667',start:'#1a6e2d',exit:'#22c55e',spawner:'#8b5cf6',arrow:'#0ea5e9',rune:'#06b6d4',fire:'#ef4444',spike:'#b45309',chest:'#eab308',player:'#fbbf24',enemyGoblin:'#ef4444',enemyArcher:'#f59e0b',enemyWraith:'#a78bfa'};
let tileSize=0,tilePad=1,animT=0;let terrainCanvas=null,terrainCtx=null,terrainValid=false;let state;
const canvas=document.getElementById('gameCanvas');const ctx=canvas.getContext('2d',{alpha:false});
const hud={hp:document.getElementById('hpVal'),hpStat:document.getElementById('hpStat'),mana:document.getElementById('manaVal'),turn:document.getElementById('turnVal'),enemy:document.getElementById('enemyVal'),spawn:document.getElementById('spawnVal'),dash:document.getElementById('dashVal'),log:document.getElementById('log')};
const btnNew=document.getElementById('btnNew'),btnHelp=document.getElementById('btnHelp'),btnPlace=document.getElementById('btnPlace'),btnDash=document.getElementById('btnDash');
const tools={arrow:document.getElementById('toolArrow'),rune:document.getElementById('toolRune'),fire:document.getElementById('toolFire'),spike:document.getElementById('toolSpike')};
function generateMaze(width,height){const w=(width%2===0)?width-1:width,h=(height%2===0)?height-1:height;const grid=Array.from({length:height},()=>Array(width).fill(1));function inBoundsCarve(x,y){return x>0&&x<w-1&&y>0&&y<h-1}const stack=[];let cx=1,cy=1;grid[cy][cx]=0;stack.push([cx,cy]);function neighbors(x,y){return[[x+2,y],[x-2,y],[x,y+2],[x,y-2]].filter(([nx,ny])=>inBoundsCarve(nx,ny)&&grid[ny][nx]===1)}while(stack.length){const [x,y]=stack[stack.length-1];const nbs=neighbors(x,y);if(!nbs.length){stack.pop();continue}const [nx,ny]=nbs[(Math.random()*nbs.length)|0];grid[ny][nx]=0;grid[y+(ny-y)/2][x+(nx-x)/2]=0;stack.push([nx,ny])}for(let y=1;y<height-1;y++){for(let x=1;x<width-1;x++){if(grid[y][x]===0&&Math.random()<.22){if(grid[y][x+1]===1)grid[y][x+1]=0;if(grid[y+1][x]===1)grid[y+1][x]=0}}}return grid}
function carveRect(grid,x,y,w,h){for(let j=0;j<h;j++)for(let i=0;i<w;i++){const gx=x+i,gy=y+j;if(gx>0&&gy>0&&gx<GRID_W-1&&gy<GRID_H-1)grid[gy][gx]=0}}
function carveGuidedPath(grid,start,exit){let x=start.x,y=start.y;grid[y][x]=0;if(y+1<GRID_H)grid[y+1][x]=0;const steps=GRID_W*2;let dirY=0;for(let s=0;s<steps&&x<exit.x-1;s++){const r=Math.random();if(r<.70){x=Math.min(GRID_W-2,x+1)}else{if(dirY===0)dirY=Math.random()<.5?-1:1;else if(Math.random()<.4)dirY=0;y=Math.max(1,Math.min(GRID_H-3,y+dirY))}grid[y][x]=0;grid[y+1][x]=0;if(Math.random()<.30&&x<exit.x-2){grid[y][x+1]=1;grid[y+1][x+1]=1;const off=(Math.random()<.5?-1:1);const yy=Math.max(1,Math.min(GRID_H-3,y+off));grid[yy][x]=0;grid[yy+1][x]=0;grid[yy][x+2]=0;grid[yy+1][x+2]=0;x=x+2;y=yy}}grid[exit.y][exit.x]=0;if(exit.x-1>=0)grid[exit.y][exit.x-1]=0}
function addRoomsAndConnectors(grid){const roomCount=3+((Math.random()*2)|0);for(let r=0;r<roomCount;r++){const rw=3+((Math.random()*3)|0),rh=3+((Math.random()*2)|0),rx=2+((Math.random()*(GRID_W-rw-4))|0),ry=2+((Math.random()*(GRID_H-rh-4))|0);carveRect(grid,rx,ry,rw,rh)}for(let y=2;y<GRID_H-2;y++){for(let x=2;x<GRID_W-2;x++){if(grid[y][x]!==1)continue;const horiz=(grid[y][x-1]===0&&grid[y][x+1]===0&&grid[y-1][x]===1&&grid[y+1][x]===1);const vert=(grid[y-1][x]===0&&grid[y+1][x]===0&&grid[y][x-1]===1&&grid[y][x+1]===1);if((horiz||vert)&&Math.random()<.08)grid[y][x]=0}}}
function randomFloor(grid){for(let tries=0;tries<6000;tries++){const x=(Math.random()*GRID_W)|0,y=(Math.random()*GRID_H)|0;if(grid[y][x]===0)return{x,y}}return{x:1,y:1}}
function dist1(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)}
function pathExists(grid,start,goal){const q=[start];const seen=new Set([start.x+','+start.y]);const dirs=[[1,0],[-1,0],[0,1],[0,-1]];while(q.length){const cur=q.shift();if(cur.x===goal.x&&cur.y===goal.y)return true;for(let i=0;i<4;i++){const nx=cur.x+dirs[i][0],ny=cur.y+dirs[i][1];if(nx<0||ny<0||nx>=GRID_W||ny>=GRID_H)continue;if(grid[ny][nx]===1)continue;const key=nx+','+ny;if(!seen.has(key)){seen.add(key);q.push({x:nx,y:ny})}}}return false}
function buildMap(){let grid,start,exit,attempts=0;do{grid=generateMaze(GRID_W,GRID_H);start={x:0,y:(GRID_H/2)|0};exit={x:GRID_W-1,y:(GRID_H/2)|0};grid[start.y][start.x]=0;if(start.x+1<GRID_W)grid[start.y][start.x+1]=0;carveGuidedPath(grid,start,exit);addRoomsAndConnectors(grid);attempts++;if(attempts>50)break}while(!pathExists(grid,start,exit));const spawners=[];const edgeOptions=[];for(let y=0;y<GRID_H;y++){if(grid[y][0]===0)edgeOptions.push({x:0,y});if(grid[y][GRID_W-1]===0)edgeOptions.push({x:GRID_W-1,y})}for(let x=0;x<GRID_W;x++){if(grid[0][x]===0)edgeOptions.push({x,y:0});if(grid[GRID_H-1][x]===0)edgeOptions.push({x,y:GRID_H-1})}edgeOptions.sort(()=>Math.random()-.5);for(const p of edgeOptions){if(dist1(p,start)<SPAWN_MIN_RADIUS)continue;if(!((p.x===start.x&&p.y===start.y)||(p.x===exit.x&&p.y===exit.y)))spawners.push(p);if(spawners.length>=3)break}while(spawners.length<3){const p=randomFloor(grid);if(dist1(p,start)<SPAWN_MIN_RADIUS)continue;if((p.x===start.x&&p.y===start.y)||(p.x===exit.x&&p.y===exit.y))continue;spawners.push(p)}if(!spawners.some(s=>s.x>=Math.floor(GRID_W*.6))){for(let tries=0;tries<200;tries++){const x=Math.floor(GRID_W*.7)+((Math.random()*Math.floor(GRID_W*.3))|0);const y=(Math.random()*GRID_H)|0;const p={x,y};if(x>=0&&x<GRID_W&&y>=0&&y<GRID_H&&grid[y][x]===0&&dist1(p,start)>=SPAWN_MIN_RADIUS){spawners[0]=p;break}}}const chests=[];for(let i=0;i<CHESTS_PER_RUN;i++){const p=randomFloor(grid);if((p.x===start.x&&p.y===start.y)||(p.x===exit.x&&p.y===exit.y)){i--;continue}if(spawners.some(s=>s.x===p.x&&s.y===p.y)){i--;continue}chests.push({x:p.x,y:p.y,opened:false})}return{grid,start,exit,spawners,chests}}

function inBounds(x,y){return x>=0&&x<GRID_W&&y>=0&&y<GRID_H}function samePos(a,b){return a.x===b.x&&a.y===b.y}
function tileToScreen(x,y){return{sx:x*tileSize,sy:y*tileSize}}function isWall(x,y){return state.map.grid[y][x]===1}
function isSpawner(x,y){return state.map.spawners.some(s=>s.x===x&&s.y===y)}function isChest(x,y){return state.map.chests.some(c=>!c.opened&&c.x===x&&c.y===y)}
function isStart(x,y){return state.map.start.x===x&&state.map.start.y===y}function isExit(x,y){return state.map.exit.x===x&&state.map.exit.y===y}
function logMsg(m){const p=document.createElement('p');p.textContent=m;hud.log.appendChild(p);hud.log.scrollTop=hud.log.scrollHeight}
function clearLog(){hud.log.innerHTML=""}function rndShuffle(a){for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j],a[i]]}return a}
function updateHUD(){hud.hp.textContent=state.hp|0;hud.mana.textContent=state.mana|0;hud.turn.textContent=state.turn|0;hud.enemy.textContent=state.enemies.length|0;hud.spawn.textContent=state.nextSpawn|0;hud.dash.textContent=state.dashCD>0?state.dashCD:'Ready';for(const k in tools)tools[k].classList.toggle('active',state.selectedTool===k);btnPlace.classList.toggle('placeMode',state.placeMode===true);btnDash.classList.toggle('dashArmed',state.dashArmed===true)}
function lineOfSightRowCol(a,b){if(a.x===b.x){const x=a.x;const y1=Math.min(a.y,b.y)+1,y2=Math.max(a.y,b.y);for(let y=y1;y<y2;y++)if(isWall(x,y))return false;return true}else if(a.y===b.y){const y=a.y;const x1=Math.min(a.x,b.x)+1,x2=Math.max(a.x,b.x);for(let x=x1;x<x2;x++)if(isWall(x,y))return false;return true}return false}
function ensureOffscreen(){if(!terrainCanvas){terrainCanvas=document.createElement('canvas');terrainCtx=terrainCanvas.getContext('2d',{alpha:false})}const rect=canvas.getBoundingClientRect();terrainCanvas.width=Math.floor(rect.width);terrainCanvas.height=Math.floor(rect.height);terrainCtx.setTransform(1,0,0,1,0,0);terrainValid=false}
function drawWallTileTo(tctx,x,y){const {sx,sy}=tileToScreen(x,y);tctx.fillStyle=COLORS.wall;tctx.fillRect(sx,sy,tileSize,tileSize);tctx.strokeStyle=COLORS.wallEdge;tctx.lineWidth=Math.max(1,tileSize*.06);tctx.strokeRect(sx+.5,sy+.5,tileSize-1,tileSize-1);tctx.save();tctx.beginPath();tctx.rect(sx+1,sy+1,tileSize-2,tileSize-2);tctx.clip();tctx.strokeStyle='rgba(255,255,255,.06)';tctx.lineWidth=Math.max(1,tileSize*.05);const step=Math.max(4,tileSize/4);for(let k=-tileSize;k<tileSize*2;k+=step){tctx.beginPath();tctx.moveTo(sx+k,sy);tctx.lineTo(sx,sy+k);tctx.stroke()}tctx.restore()}
function drawTerrainAll(){const rect=canvas.getBoundingClientRect();terrainCtx.clearRect(0,0,rect.width,rect.height);for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++){if(isWall(x,y))drawWallTileTo(terrainCtx,x,y);else{const {sx,sy}=tileToScreen(x,y);terrainCtx.fillStyle=COLORS.floor;terrainCtx.fillRect(sx+tilePad,sy+tilePad,tileSize-tilePad*2,tileSize-tilePad*2)}}drawOutlineRectTo(terrainCtx,state.map.start.x,state.map.start.y,COLORS.start,.35);drawOutlineRectTo(terrainCtx,state.map.exit.x,state.map.exit.y,COLORS.exit,.35);for(const s of state.map.spawners)drawOutlineRectTo(terrainCtx,s.x,s.y,COLORS.spawner,.35);for(const c of state.map.chests)if(!c.opened){drawOutlineRectTo(terrainCtx,c.x,c.y,COLORS.chest,.45);const {sx,sy}=tileToScreen(c.x,c.y);const s2=Math.max(4,tileSize*.35);terrainCtx.fillStyle=COLORS.chest;terrainCtx.fillRect(sx+(tileSize-s2)/2,sy+(tileSize-s2)/2,s2,s2)}terrainValid=true}
function drawOutlineRectTo(tctx,x,y,color,alpha=.28){const {sx,sy}=tileToScreen(x,y);tctx.save();tctx.globalAlpha=alpha;tctx.strokeStyle=color;tctx.setLineDash([4,3]);tctx.lineWidth=Math.max(1,tileSize*.06);tctx.strokeRect(sx+tilePad,sy+tilePad,tileSize-tilePad*2,tileSize-tilePad*2);tctx.restore()}
function drawOutlineRect(x,y,c,a){drawOutlineRectTo(ctx,x,y,c,a)}
function drawHPBar(x,y,ratio){const {sx,sy}=tileToScreen(x,y);const w=tileSize-tilePad*2,h=Math.max(3,tileSize*.09);const bx=sx+tilePad,by=sy+tilePad*.7;ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(bx,by,w,h);ctx.fillStyle=ratio>.5?'#22c55e':(ratio>.25?'#f59e0b':'#ef4444');ctx.fillRect(bx,by,w*ratio,h)}
function outlineRangeTiles(cx,cy,r,color){for(let y=cy-r;y<=cy+r;y++){for(let x=cx-r;x<=cx+r;x++){if(!inBounds(x,y))continue;if(Math.abs(cx-x)+Math.abs(cy-y)<=r)drawOutlineRect(x,y,color,.18)}}}
function highlightPlacementArea(){for(let y=state.player.y-PLACE_RADIUS;y<=state.player.y+PLACE_RADIUS;y++){for(let x=state.player.x-PLACE_RADIUS;x<=state.player.x+PLACE_RADIUS;x++){if(!inBounds(x,y))continue;const check=isValidPlacement(x,y);if(check.ok)drawOutlineRect(x,y,COLORS.player,.25)}}}
function addFX(kind,x,y,life=18){state.fx.push({kind,x,y,life,max:life})}
function drawEffects(){const next=[];for(let i=0;i<state.fx.length;i++){const fx=state.fx[i];fx.life--;if(fx.life<=0)continue;const {sx,sy}=tileToScreen(fx.x,fx.y);ctx.save();if(fx.kind==='hit'){ctx.globalAlpha=fx.life/fx.max;ctx.strokeStyle='#e8ecff';ctx.lineWidth=Math.max(1,tileSize*.06);ctx.beginPath();ctx.arc(sx+tileSize/2,sy+tileSize/2,tileSize*.3*(1+(fx.max-fx.life)/fx.max),0,Math.PI*2);ctx.stroke()}else if(fx.kind==='slow'){ctx.globalAlpha=.5*(fx.life/fx.max);ctx.strokeStyle='#06b6d4';ctx.lineWidth=2;ctx.strokeRect(sx+tilePad,sy+tilePad,tileSize-tilePad*2,tileSize-tilePad*2)}else if(fx.kind==='fire'){ctx.globalAlpha=.5*(fx.life/fx.max);ctx.fillStyle='rgba(239,68,68,.25)';ctx.beginPath();ctx.arc(sx+tileSize/2,sy+tileSize/2,tileSize*.45,0,Math.PI*2);ctx.fill()}ctx.restore();next.push(fx)}state.fx=next}
function draw(){const rect=canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;canvas.width=Math.floor(rect.width*dpr);canvas.height=Math.floor(rect.height*dpr);ctx.setTransform(dpr,0,0,dpr,0,0);tileSize=rect.width/GRID_W;tilePad=Math.max(1,Math.floor(tileSize*.03));ensureOffscreen();if(!terrainValid)drawTerrainAll();ctx.save();if(state.placeMode){const {sx:psx,sy:psy}=tileToScreen(state.player.x,state.player.y);const scale=1.4;ctx.translate(rect.width/2,rect.height/2);ctx.scale(scale,scale);ctx.translate(-psx-tileSize/2,-psy-tileSize/2)}ctx.drawImage(terrainCanvas,0,0,rect.width,rect.height);if(state.placeMode)highlightPlacementArea();const pulse=(Math.sin(animT/600)+1)/2;for(const s of state.map.spawners){const {sx,sy}=tileToScreen(s.x,s.y);ctx.save();ctx.globalAlpha=.35+.35*pulse;ctx.strokeStyle=COLORS.spawner;ctx.lineWidth=Math.max(2,tileSize*.1);ctx.beginPath();ctx.arc(sx+tileSize/2,sy+tileSize/2,tileSize*.42+tileSize*.08*pulse,0,Math.PI*2);ctx.stroke();ctx.restore()}if(state.placeMode){for(const t of state.towers){if(t.type==='arrow')outlineRangeTiles(t.x,t.y,TRAP_RANGE,COLORS.arrow);if(t.type==='rune')outlineRangeTiles(t.x,t.y,RUNE_RADIUS,COLORS.rune);if(t.type==='fire')outlineRangeTiles(t.x,t.y,FIRE_RADIUS,COLORS.fire);if(t.type==='spike')drawOutlineRect(t.x,t.y,COLORS.spike,.25)}}for(const t of state.towers){const color=t.type==='arrow'?COLORS.arrow:t.type==='rune'?COLORS.rune:t.type==='fire'?COLORS.fire:COLORS.spike;const {sx,sy}=tileToScreen(t.x,t.y);ctx.fillStyle=color;ctx.fillRect(sx+tilePad,sy+tilePad,tileSize-tilePad*2,tileSize-tilePad*2)}for(const e of state.enemies){const col=e.kind==='goblin'?COLORS.enemyGoblin:e.kind==='archer'?COLORS.enemyArcher:COLORS.enemyWraith;const {sx,sy}=tileToScreen(e.x,e.y);ctx.fillStyle=col;ctx.fillRect(sx+tilePad,sy+tilePad,tileSize-tilePad*2,tileSize-tilePad*2);const maxhp=e.maxhp||(e.kind==='goblin'?ENEMY.goblin.hp:e.kind==='archer'?ENEMY.archer.hp:ENEMY.wraith.hp);drawHPBar(e.x,e.y,Math.max(0,e.hp)/maxhp)}const {sx:psx2,sy:psy2}=tileToScreen(state.player.x,state.player.y);ctx.fillStyle=COLORS.player;ctx.fillRect(psx2+tilePad,psy2+tilePad,tileSize-tilePad*2,tileSize-tilePad*2);drawEffects();ctx.restore();if(state.won||state.lost){ctx.save();ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(0,0,rect.width,rect.height);ctx.fillStyle=state.won?'#7dff9d':'#ff6b6b';ctx.font='bold 26px system-ui';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(state.won?'YOU ESCAPED!':'DEFEATED',rect.width/2,rect.height/2-10);ctx.fillStyle='#e8ecff';ctx.font='16px system-ui';ctx.fillText('Tap "New Game" to try again',rect.width/2,rect.height/2+18);ctx.restore()}}
window.addEventListener('resize',()=>{ensureOffscreen();terrainValid=false});
document.addEventListener('keydown',(e)=>{if(state.won||state.lost||state.placeMode)return;const key=e.key.toLowerCase();if(['arrowup','w'].includes(key))playerMove(0,-1,e.shiftKey);else if(['arrowdown','s'].includes(key))playerMove(0,1,e.shiftKey);else if(['arrowleft','a'].includes(key))playerMove(-1,0,e.shiftKey);else if(['arrowright','d'].includes(key))playerMove(1,0,e.shiftKey);else if(key==='q')toggleDashArm()});
document.querySelectorAll('.padbtn').forEach(btn=>{btn.addEventListener('click',()=>{if(state.won||state.lost||state.placeMode)return;const dir=btn.getAttribute('data-dir');if(dir==='up')playerMove(0,-1,false);if(dir==='down')playerMove(0,1,false);if(dir==='left')playerMove(-1,0,false);if(dir==='right')playerMove(1,0,false)})});
for(const k in tools)tools[k].addEventListener('click',()=>{state.selectedTool=k;updateHUD()});
btnDash.addEventListener('click',()=>{toggleDashArm()});
function toggleDashArm(){if(state.dashCD>0||state.mana<DASH_COST){logMsg(state.dashCD>0?`Dash on cooldown (${state.dashCD}).`:`Need ${DASH_COST} mana to dash.`);return}state.dashArmed=!state.dashArmed;updateHUD()}
function canvasPosToTile(clientX,clientY){const rect=canvas.getBoundingClientRect();const x=Math.floor(Math.max(0,Math.min(rect.width-1,clientX-rect.left))/(rect.width/GRID_W));const y=Math.floor(Math.max(0,Math.min(rect.height-1,clientY-rect.top))/(rect.height/GRID_H));return{x,y}}
btnPlace.addEventListener('click',()=>{if(state.won||state.lost)return;if(!state.selectedTool){logMsg('Select a tool first.');return}const cost=COSTS[state.selectedTool];if(state.mana<cost){logMsg(`Not enough mana (${cost} needed).`);return}state.placeMode=!state.placeMode;if(!state.placeMode)state.hover=null;updateHUD()});
canvas.addEventListener('click',(e)=>{if(!state.placeMode||state.won||state.lost)return;const {x,y}=canvasPosToTile(e.clientX,e.clientY);const check=isValidPlacement(x,y);if(!check.ok){logMsg(`Can't place: ${check.reason}`);return}tryPlace(x,y)},{passive:true});
function rebuildFlow(){const INF=1e9;const dist=Array.from({length:GRID_H},()=>Array(GRID_W).fill(INF));const q=[];const start={x:state.player.x,y:state.player.y};dist[start.y][start.x]=0;q.push(start);const dirs=[[1,0],[-1,0],[0,1],[0,-1]];while(q.length){const cur=q.shift();const d=dist[cur.y][cur.x]+1;for(let i=0;i<4;i++){const nx=cur.x+dirs[i][0],ny=cur.y+dirs[i][1];if(!inBounds(nx,ny))continue;if(isWall(nx,ny))continue;if(d<dist[ny][nx]){dist[ny][nx]=d;q.push({x:nx,y:ny})}}}state.flowDist=dist;state.flowDirty=false}

function playerMove(dx,dy,useDashKey=false){if(state.won||state.lost)return;let didDash=false;if((state.dashArmed||useDashKey)&&state.dashCD===0&&state.mana>=DASH_COST){let nx=state.player.x,ny=state.player.y;for(let step=0;step<2;step++){const tx=nx+dx,ty=ny+dy;if(!inBounds(tx,ty)||isWall(tx,ty))break;nx=tx;ny=ty}if(nx!==state.player.x||ny!==state.player.y){state.player.x=nx;state.player.y=ny;state.mana-=DASH_COST;state.dashCD=DASH_CD;state.dashArmed=false;didDash=true;logMsg('Dashed!')}}if(!didDash){const nx=state.player.x+dx,ny=state.player.y+dy;if(!inBounds(nx,ny)||isWall(nx,ny))return;state.player.x=nx;state.player.y=ny}for(const c of state.map.chests){if(!c.opened&&samePos(c,state.player)){c.opened=true;state.mana+=CHEST_MANA;terrainValid=false;logMsg(`Opened chest: +${CHEST_MANA} mana.`)}}if(state.player.x===state.map.exit.x&&state.player.y===state.map.exit.y){state.won=true;updateHUD();return}state.flowDirty=true;advanceTurn()}
function tryPlace(x,y){const t=state.selectedTool,cost=COSTS[t];state.mana-=cost;if(t==='arrow')state.towers.push({x,y,type:t,ammo:ARROW_AMMO});else state.towers.push({x,y,type:t});state.placeMode=false;state.hover=null;logMsg(`Placed ${t} at (${x},${y}).`);advanceTurn()}
function isValidPlacement(x,y){if(!inBounds(x,y))return{ok:false,reason:'out of bounds'};if(isWall(x,y))return{ok:false,reason:'wall tile'};if(isStart(x,y)||isExit(x,y))return{ok:false,reason:'reserved tile'};if(isSpawner(x,y))return{ok:false,reason:'spawner tile'};if(isChest(x,y))return{ok:false,reason:'chest tile'};if(state.player.x===x&&state.player.y===y)return{ok:false,reason:'on player'};const dist=Math.abs(state.player.x-x)+Math.abs(state.player.y-y);if(dist>PLACE_RADIUS)return{ok:false,reason:`must place within ${PLACE_RADIUS} tiles of player`};if(state.towers.some(t=>t.x===x&&t.y===y))return{ok:false,reason:'occupied by a trap'};const cost=COSTS[state.selectedTool];if(state.mana<cost)return{ok:false,reason:`need ${cost} mana`};return{ok:true}}
function flashHP(){hud.hpStat.classList.add('flash');setTimeout(()=>hud.hpStat.classList.remove('flash'),250)}
function advanceTurn(){if(state.won||state.lost)return;state.turn+=1;state.mana+=PASSIVE_MANA;if(state.dashCD>0)state.dashCD-=1;towersAct();enemiesPreEffects();try{enemiesAct()}catch(err){logMsg(`AI error: ${err.message}`)}handleSpawns();checkWinLose();updateHUD()}
function rewardFor(k){return k==='goblin'?ENEMY.goblin.reward:k==='archer'?ENEMY.archer.reward:ENEMY.wraith.reward}
function towersAct(){if(!state.towers.length)return;const survivors=[];for(const t of state.towers){if(t.type==='arrow'){let best=null,bestD=1e9;for(const e of state.enemies){const d=Math.abs(t.x-e.x)+Math.abs(t.y-e.y);if(d<=TRAP_RANGE&&(t.x===e.x||t.y===e.y)&&lineOfSightRowCol(t,e)){if(d<bestD){best=e;bestD=d}}}if(best&&(t.ammo??0)>0){best.hp-=TRAP_DMG;addFX('hit',best.x,best.y);t.ammo=(t.ammo??ARROW_AMMO)-1}if((t.ammo??0)>0)survivors.push(t);else terrainValid=false}else if(t.type==='rune'){let any=false;for(const e of state.enemies)if(Math.abs(t.x-e.x)+Math.abs(t.y-e.y)<=RUNE_RADIUS){e.slowTurns=Math.max(e.slowTurns||0,RUNE_SLOW_TURNS);any=true}if(any)addFX('slow',t.x,t.y,14);survivors.push(t)}else if(t.type==='fire'){let any=false;for(const e of state.enemies)if(Math.abs(t.x-e.x)+Math.abs(t.y-e.y)<=FIRE_RADIUS){e.hp-=FIRE_DMG;e.burn=Math.max(e.burn||0,BURN_TURNS);any=true;addFX('fire',e.x,e.y,12)}survivors.push(t)}else if(t.type==='spike'){survivors.push(t)}}let add=0;const alive=[];for(const e of state.enemies){if(e.hp<=0)add+=rewardFor(e.kind);else alive.push(e)}if(add>0)logMsg(`Enemies defeated (+${add} mana).`);state.mana+=add;state.enemies=alive;state.towers=survivors}
function enemiesPreEffects(){let add=0;const alive=[];for(const e of state.enemies){if(e.burn&&e.burn>0){e.hp-=BURN_DMG;e.burn--;addFX('fire',e.x,e.y,10)}if(e.hp<=0)add+=rewardFor(e.kind);else alive.push(e)}if(add>0){state.mana+=add;logMsg(`Burned enemies defeated (+${add} mana).`)}state.enemies=alive}
function buildDensityField(){const f=Array.from({length:GRID_H},()=>Array(GRID_W).fill(0));for(const e of state.enemies)f[e.y][e.x]+=1;return f}
function densityScore(field,x,y){const self=field[y][x];let adj=0;for(const d of [[1,0],[-1,0],[0,1],[0,-1]]){const nx=x+d[0],ny=y+d[1];if(inBounds(nx,ny))adj+=field[ny][nx]}return DENSITY_TILE_WEIGHT*self+DENSITY_NEIGHBOR_WEIGHT*adj}
function isMelee(e){return e.kind==='goblin'||e.kind==='wraith'}
function enemiesAct(){if(!state.flowDist||state.flowDirty)rebuildFlow();const haveFlow=Array.isArray(state.flowDist);const density=buildDensityField();const order=rndShuffle(state.enemies.slice());const occupied=new Set([state.player.x+','+state.player.y]);for(const e of state.enemies)occupied.add(e.x+','+e.y);for(const e of order){if(e.idle&&e.idle>0){e.idle--;continue}if(e.kind==='archer'){e.cooldown=Math.max(0,(e.cooldown??ENEMY.archer.cd)-1);const inLoS=lineOfSightRowCol(e,state.player)&&Math.abs(e.x-state.player.x)+Math.abs(e.y-state.player.y)<=ENEMY.archer.range;if(inLoS&&e.cooldown<=0){state.hp-=ENEMY.archer.dmg;flashHP();logMsg(`Skeleton archer hits you for ${ENEMY.archer.dmg}.`);e.cooldown=ENEMY.archer.cd;if(state.hp<=0)break}else if(!inLoS&&e.cooldown<=0){e.cooldown=1}}const slowedNow=(e.slowTurns&&e.slowTurns>0);if(slowedNow&&(state.turn%2===1)){e.slowTurns--;continue}const far=Math.abs(e.x-state.player.x)+Math.abs(e.y-state.player.y)>PATROL_RADIUS;if(far&&Math.random()<.5){continue}
let nx=e.x,ny=e.y;if(e.kind==='wraith'||!haveFlow){const dirs=[[1,0],[-1,0],[0,1],[0,-1]];let best={x:e.x,y:e.y,d:Math.abs(e.x-state.player.x)+Math.abs(e.y-state.player.y)};for(const d of dirs){const tx=e.x+d[0],ty=e.y+d[1];if(!inBounds(tx,ty)||(!e.kind==='wraith'&&isWall(tx,ty)))continue;const dd=Math.abs(tx-state.player.x)+Math.abs(ty-state.player.y);const key=tx+','+ty;if(dd<best.d&&!occupied.has(key))best={x:tx,y:ty,d:dd}}nx=best.x;ny=best.y}else{const dirs=[[1,0],[-1,0],[0,1],[0,-1]];const currentV=state.flowDist[e.y][e.x];let bestV=currentV,best={x:e.x,y:e.y};for(const d of dirs){const tx=e.x+d[0],ty=e.y+d[1];if(!inBounds(tx,ty)||isWall(tx,ty))continue;let v=state.flowDist[ty][tx];v+=densityScore(density,tx,ty);if(v<bestV){bestV=v;best={x:tx,y:ty}}}if(e.kind==='archer'&&bestV>=currentV){let meleeNearbyCloser=false;for(const d of dirs){const tx=e.x+d[0],ty=e.y+d[1];const other=state.enemies.find(en=>en.x===tx&&en.y===ty&&isMelee(en));if(other&&state.flowDist[ty][tx]<currentV){meleeNearbyCloser=true;break}}if(meleeNearbyCloser){const sameDist=dirs.map(d=>({x:e.x+d[0],y:e.y+d[1]})).filter(p=>inBounds(p.x,p.y)&&!isWall(p.x,p.y)&&state.flowDist[p.y][p.x]===currentV);sameDist.sort((a,b)=>densityScore(density,a.x,a.y)-densityScore(density,b.x,b.y));for(const p of sameDist){const key=p.x+','+p.y;if(!occupied.has(key)){best={x:p.x,y:p.y};bestV=currentV;break}}}}if(bestV>=currentV&&Math.random()<PATIENCE_PROB){best={x:e.x,y:e.y}}nx=best.x;ny=best.y}
const key=nx+','+ny;if(!occupied.has(key)){occupied.add(key);e.x=nx;e.y=ny}
const idx=state.towers.findIndex(t=>t.type==='spike'&&t.x===e.x&&t.y===e.y);if(idx!==-1){e.hp-=SPIKE_DMG;state.towers.splice(idx,1);logMsg(`Spike hits for ${SPIKE_DMG}.`);addFX('hit',e.x,e.y)}
if(samePos(e,state.player)){const dmg=e.kind==='goblin'?ENEMY.goblin.touch:e.kind==='archer'?ENEMY.archer.touch:ENEMY.wraith.touch;state.hp-=dmg;flashHP();logMsg(`Enemy hit you for ${dmg} damage.`);if(state.hp<=0)break}
if(e.slowTurns&&e.slowTurns>0&&!(state.turn%2===1))e.slowTurns--}
let add=0;const survivors=[];for(const e of state.enemies){if(e.hp<=0)add+=rewardFor(e.kind);else survivors.push(e)}if(add>0){state.mana+=add;logMsg(`Enemies defeated (+${add} mana).`)}state.enemies=survivors}
function spawnCooldown(t){return baseSpawnCooldown(t)}function spawnCount(t,progress){return (1+Math.floor(t/15))+(progress>.5?1:0)}
function pickSpawnPos(){const minR=SPAWN_MIN_RADIUS;const ring=state.map.spawners.filter(s=>{const d=Math.abs(s.x-state.player.x)+Math.abs(s.y-state.player.y);return d>=Math.max(8,minR)&&d<=18});const behindRing=ring.filter(s=>s.x<=state.player.x-2);const pool1=behindRing.length?behindRing:(ring.length?ring:state.map.spawners);const candidates=pool1.filter(p=>{const d=Math.abs(p.x-state.player.x)+Math.abs(p.y-state.player.y);return d>=minR&&!(p.x===state.player.x&&p.y===state.player.y)&&!state.enemies.some(e=>e.x===p.x&&e.y===p.y)});if(candidates.length)return candidates[(Math.random()*candidates.length)|0];let best=null,bestD=-1;for(const p of state.map.spawners){const d=Math.abs(p.x-state.player.x)+Math.abs(p.y-state.player.y);if(d>=minR&&d>bestD){best=p;bestD=d}}return best}
function handleSpawns(){const nearCount=state.enemies.reduce((n,e)=>n+(Math.abs(e.x-state.player.x)+Math.abs(e.y-state.player.y)<=4?1:0),0);if(nearCount>=5){state.nextSpawn=Math.max(state.nextSpawn,2);return}state.nextSpawn-=1;if(state.nextSpawn<=0){const free=ENEMY_CAP-state.enemies.length;if(free>0){const progress=state.player.x/(GRID_W-1);const desired=Math.min(spawnCount(state.turn,progress),free);let count=0;for(let i=0;i<desired;i++){const pos=pickSpawnPos();if(!pos)break;const roll=Math.random();let kind='goblin';if(roll>.8)kind='wraith';else if(roll>.55)kind='archer';const base=ENEMY[kind];state.enemies.push({x:pos.x,y:pos.y,hp:base.hp,maxhp:base.hp,kind,cooldown:ENEMY.archer.cd,idle:(nearCount>=5?1:0)});count++}if(count>0)logMsg(count===1?'An enemy emerged from a portal!':`${count} enemies emerged from portals!`)}state.nextSpawn=spawnCooldown(state.turn)}}
function checkWinLose(){if(state.player.x===state.map.exit.x&&state.player.y===state.map.exit.y){state.won=true;logMsg('You reached the exit. Victory!')}if(state.hp<=0){state.lost=true;logMsg('You have fallen...')}}
codex/start-enemy-spawn-on-first-move-and-update-traps-i2t3w2
function resetState(){const map=buildMap();state={map,turn:0,hp:START_HP,mana:START_MANA,nextSpawn:1,player:{x:map.start.x,y:map.start.y},enemies:[],towers:[],placeMode:false,selectedTool:'arrow',won:false,lost:false,fx:[],hover:null,flowDist:null,flowDirty:true,dashCD:0,dashArmed:false};clearLog();logMsg('Enemies spawn after first move; traps place within 4 tiles of player.');const rect=canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;canvas.width=Math.floor(rect.width*dpr);canvas.height=Math.floor(rect.height*dpr);ctx.setTransform(dpr,0,0,dpr,0,0);tileSize=rect.width/GRID_W;tilePad=Math.max(1,Math.floor(tileSize*.03));ensureOffscreen();terrainValid=false;updateHUD()}
btnNew.addEventListener('click',resetState);
btnHelp.addEventListener('click',()=>{
    alert('Enemies spawn after first move.\n• Traps place within 4 tiles of player.\n• Placement mode zooms and highlights valid tiles.\n• Movement trail removed.');
});

function resetState(){const map=buildMap();state={map,turn:0,hp:START_HP,mana:START_MANA,nextSpawn:1,player:{x:map.start.x,y:map.start.y},enemies:[],towers:[],visited:Array.from({length:GRID_H},()=>Array(GRID_W).fill(false)),placeMode:false,selectedTool:'arrow',won:false,lost:false,fx:[],hover:null,flowDist:null,flowDirty:true,dashCD:0,dashArmed:false};state.visited[state.player.y][state.player.x]=true;clearLog();logMsg('v2.9.5: enemies spawn after first move; traps place within 4 tiles.');const rect=canvas.getBoundingClientRect();const dpr=window.devicePixelRatio||1;canvas.width=Math.floor(rect.width*dpr);canvas.height=Math.floor(rect.height*dpr);ctx.setTransform(dpr,0,0,dpr,0,0);tileSize=rect.width/GRID_W;tilePad=Math.max(1,Math.floor(tileSize*.03));ensureOffscreen();terrainValid=false;updateHUD()}
btnNew.addEventListener('click',resetState);btnHelp.addEventListener('click',()=>{alert('2.9.3 hotfix:\n• Fixed AI (removed stray rebuildFlow override).\n• Early win check after movement.\n• Chests are brighter and filled.\n• Archer cooldown clamped.\n• Prevented enemy swap moves.\n• Enemy phase wrapped in try/catch.')});
main
function loop(ts){animT=ts;draw();requestAnimationFrame(loop)}resetState();requestAnimationFrame(loop);
})();
